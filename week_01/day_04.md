## `C++` 智能指针总结

### 1. 引入目的
- **自动化内存管理**：通过 `RAII`（资源获取即初始化）机制自动管理内存，减少手动 `new/delete` 的复杂性。
- **核心目标**：防止内存泄漏、悬挂指针、双重释放等问题。

---

### 2. 原生指针的缺陷
| 问题类型          | 描述                                                                 |
|-------------------|----------------------------------------------------------------------|
| **内存泄漏**       | 分配内存后忘记释放（`delete`）                                       |
| **悬挂指针**       | 指针指向的内存被释放后，仍被访问                                     |
| **双重释放**       | 多个指针指向同一内存，重复调用 `delete` 导致未定义行为               |

---

### 3. 智能指针特性
| 特性              | 说明                                                                 |
|-------------------|----------------------------------------------------------------------|
| **自动销毁**       | 生命周期结束时自动释放资源                                           |
| **引用计数**       | `shared_ptr` 跟踪引用数量，计数归零时释放资源                         |
| **避免内存泄漏**   | 通过 `RAII` 确保资源自动释放                                            |
| **类型安全**       | 提供更严格的资源所有权管理（注：类型检查与原生指针一致）             |
| **独占所有权**     | `unique_ptr` 确保资源仅由一个所有者管理                               |
| **共享所有权**     | `shared_ptr` 允许多个指针共享同一资源                                 |
| **观察者模式**     | `weak_ptr` 用于观察资源而不影响其生命周期                             |

---

### 4. `std::unique_ptr`
#### 核心特性
- **独占所有权**：同一时刻仅一个 `unique_ptr` 拥有资源。
- **轻量级**：无引用计数，性能开销小。
- **不可拷贝**：只能通过移动语义转移所有权。

#### 构造函数与操作
| 操作类型          | 行为                                                                 |
|-------------------|----------------------------------------------------------------------|
| 默认构造          | 创建空的 `unique_ptr`                                                |
| 指针构造          | 从裸指针接管所有权                                                   |
| 移动构造/赋值     | 转移资源所有权，原指针置空                                           |
| 自定义删除器      | 支持自定义删除器，用于管理非 `new` 分配的资源（如文件句柄）          |

---

### 5. `std::shared_ptr`
#### 核心特性
- **共享所有权**：多个 `shared_ptr` 可指向同一资源。
- **引用计数**：通过控制块管理强引用（`use_count`）和弱引用（`weak_count`）。

| 操作类型          | 行为                                                                 |
|-------------------|----------------------------------------------------------------------|
| **默认构造**       | 创建空的 `shared_ptr`                                                |
| **指针构造**       | 创建新控制块并接管资源（注：避免用同一裸指针初始化多个 `shared_ptr`）|
| **拷贝构造/赋值**  | 增加引用计数                                                         |
| **移动构造/赋值**  | 转移所有权，原指针置空                                               |
| **自定义删除器**   | 支持自定义删除器，用于管理非 `new` 分配的资源                        |


```cpp
std::shared_ptr<int> ptr1(new int(10)); // 从裸指针构造
std::shared_ptr<int> ptr2 = ptr1; // 拷贝构造，引用计数增加
std::shared_ptr<int> ptr3 = std::move(ptr1); // 移动构造，ptr1 置空
```
---

### 6. `std::weak_ptr`
#### 核心特性 
- 非拥有观察者：不增加引用计数，不管理资源生命周期。
- 解决循环引用：打破 `shared_ptr` 双向依赖导致的资源泄漏。
- `lock()`返回一个 `shared_ptr`，若资源存在则有效，否则为空
- `expired()`检查资源是否已被释放

```c++
std::shared_ptr<int> sharedPtr = std::make_shared<int>(10);
std::weak_ptr<int> weakPtr = sharedPtr;

if (auto lockedPtr = weakPtr.lock()) {
    // 资源仍存在，lockedPtr 是一个有效的 shared_ptr
} else {
    // 资源已被释放
}
```
