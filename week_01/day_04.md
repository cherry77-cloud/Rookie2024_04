## C++ 智能指针总结

### 1. 引入目的
- **自动化内存管理**：通过 RAII（资源获取即初始化）机制自动管理内存，减少手动 `new/delete` 的复杂性。
- **核心目标**：防止内存泄漏、悬挂指针、双重释放等问题。

### 2. 原生指针的缺陷
| 问题类型          | 描述                                                                 |
|-------------------|----------------------------------------------------------------------|
| **内存泄漏**       | 分配内存后忘记释放（`delete`）                                       |
| **悬挂指针**       | 指针指向的内存被释放后，仍被访问                                     |
| **双重释放**       | 多个指针指向同一内存，重复调用 `delete` 导致未定义行为               |

### 3. 智能指针特性
| 特性              | 说明                                                                 |
|-------------------|----------------------------------------------------------------------|
| **自动销毁**       | 生命周期结束时自动释放资源                                           |
| **引用计数**       | `shared_ptr` 跟踪引用数量，计数归零时释放资源                         |
| **避免内存泄漏**   | 通过 RAII 确保资源自动释放                                            |
| **类型安全**       | 更严格的资源所有权管理（注：类型检查与原生指针一致）                 |

### 4. `std::unique_ptr`
#### 核心特性
- **独占所有权**：同一时刻仅一个 `unique_ptr` 拥有资源。
- **轻量级**：无引用计数，性能开销小。
- **不可拷贝**：只能通过移动语义转移所有权。

#### 构造函数与操作
| 操作类型          | 行为                                                                 |
|-------------------|----------------------------------------------------------------------|
| 默认构造          | 创建空的 `unique_ptr`                                                |
| 指针构造          | 从裸指针接管所有权                                                   |
| 移动构造/赋值     | 转移资源所有权，原指针置空                                           |

### 5. `std::shared_ptr`
#### 核心特性
- **共享所有权**：多个 `shared_ptr` 可指向同一资源。
- **引用计数**：通过控制块管理强引用（`use_count`）和弱引用（`weak_count`）。

#### 控制块结构
```cpp
struct ControlBlock {
    int use_count;   // 强引用计数
    int weak_count;  // 弱引用计数
    T* ptr;          // 指向实际资源
};
```
